from defs import *
from harvest_stuff import *
import random
import pathfinding
from miscellaneous import *
from movement import *
from _custom_constants import *
import movement

__pragma__('noalias', 'name')
__pragma__('noalias', 'undefined')
__pragma__('noalias', 'Infinity')
__pragma__('noalias', 'keys')
__pragma__('noalias', 'get')
__pragma__('noalias', 'set')
__pragma__('noalias', 'type')
__pragma__('noalias', 'update')


def run_carrier(creep, creeps, all_structures, constructions, dropped_all, repairs):
    """
    technically same with hauler, but more concentrated in carrying itself.
        and it's for remote mining ONLY.
    :param Game.creep creep: Game.creep
    :param creeps: creep.room.find(FIND_MY_CREEPS)
    :param all_structures: creep.room.find(FIND_STRUCTURES)
    :param constructions: FIND_CONSTRUCTION_SITES
    :param dropped_all: creep.room.find(FIND_DROPPED_RESOURCES)
    :param repairs:
    :return:
    """

    # todo ÌòÑ Î¨∏Ï†úÏ†ê:
    # - Í±¥ÏÑ§ ÌïÑÏöî Ïãú Î∞∞Ï†ï.(?)
    # - Ïö¥ÏÜ° Ïãú Î™©ÌëúÏßÄÏ†ê Î∞∞Ï†ïÍ¥ÄÎ†®: ÏûêÍæ∏ Ïä§Ìè∞ÎãπÏãú ÏúÑÏπòÏóêÏÑú Í∞ÄÏû• Í∞ÄÍπåÏö¥Í±∞Ïóê Ìï¥Î≤ÑÎ¶º.
    # - ÏõêÎûò ÌîΩÏóÖÏúÑÏπò ÌååÍ¥¥ÎêêÏùÑ Ïãú Î∞∞Ï†ï Í¥ÄÎ†®. Î∞©Ïóê ÏûêÏõêÏù¥ ÎëòÏùºÎïå ÏóâÏºúÎ≤ÑÎ¶º. ÏàòÎ¶¨Í∞Ä ÏãúÍ∏âÌï®.
    # - Ïö¥ÏÜ°Ï§ë Îñ®Ïñ¥ÏßÑÍ±∞ Ï£ºÏõ†ÎäîÎç∞ ÏùºÏ†ïÎüâÎ≥¥Îã§ ÎßéÏúºÎ©¥ Í±ç ÎèåÏïÑÍ∞ÄÍ≤åÎÅî. Î∞©Í∏à Î≠î 10ÎÇ®ÏïòÎäîÎç∞ Í≥ÑÏÜçÍ∞Ä...

    # Ïù∏ÏÉùÏ†ïÎ¶¨Î™®Îìú ÎèåÏûÖ(?)
    end_is_near = 40

    # 
    min_distance_to_other_containers = 6

    # in case it's gonna die soon. switch to some other
    if _.sum(creep.carry) > 0 and creep.ticksToLive < end_is_near and \
            (creep.memory.laboro == 0 or (creep.memory.laboro == 1 and creep.memory.priority != 2)):
        creep.say('endIsNear')
        creep.memory.laboro = 1
        creep.memory.priority = 2
    elif _.sum(creep.carry) == 0 and creep.ticksToLive < end_is_near:
        creep.suicide()
        return
    elif not creep.memory.upgrade_target:
        creep.memory.upgrade_target = creep.room.controller['id']
    elif not creep.memory.home_room:
        creep.memory.home_room = creep.room.name
    elif not creep.memory[haul_resource]:
        creep.memory[haul_resource] = haul_all

    # ÌîΩÏóÖÏóê Ï†ÄÏû•Îêú Í∏∏Ïù¥ ÏûàÎÇò ÌôïÏù∏ÌïúÎã§. Ïö∞ÏÑ† Ïù¥Î¶¨ ÎßåÎì§Í∏¥ ÌñàÎäîÎç∞ Ïä§Ìè∞Î∂ÄÌÑ∞ Î©îÎ™®Î¶¨ÌôîÎêòÏÑú ÏùòÎØ∏Í∞Ä ÏóÜÏñ¥ÏßÑÎìØ
    if not creep.memory[to_pickup] and Game.getObjectById(creep.memory.pickup):
        # print(Game.getObjectById(creep.memory.pickup))
        objs = []
        for i in Game.getObjectById(creep.memory.pickup).room.memory[resources][RESOURCE_ENERGY]:
            objs.append(Game.getObjectById(i))
        for i in Game.getObjectById(creep.memory.pickup).room.memory[resources][minerals]:
            objs.append(Game.getObjectById(i))
        # for i in Game.getObjectById(creep.memory.pickup).room.memory[STRUCTURE_KEEPER_LAIR]:
        #     objs.append(Game.getObjectById(i))
        opts = {'trackCreeps': False, 'refreshMatrix': True, 'pass_walls': False,
                'costByArea': {'objects': objs, 'size': 1, 'cost': 6}}
        if creep.memory.birthplace:
            birthplace = RoomPosition(creep.memory.birthplce.x, creep.memory.birthplce.y, creep.memory.birthplce.roomName)
        else:
            birthplace = creep.pos
        # Í∞ÄÎäîÍ∏∏ Ï†ÄÏû•.
        creep.memory[to_pickup] = \
            PathFinder.search(birthplace, Game.getObjectById(creep.memory.pickup).pos,
                              {'plainCost': 2, 'swampCost': 3,
                               'roomCallback':
                                   lambda room_name:
                                   pathfinding.Costs(room_name, opts).load_matrix()
                               }, ).path
        # Í∑∏Î¶¨Í≥† ÏúÑÏóêÍ∫º Í∑∏ÎåÄÎ°ú Ïó≠ÏàúÏúºÎ°ú ÎÇòÏó¥Ìï¥ÏÑú ÎèåÏïÑÍ∞ÄÎäîÍ∏∏ Ï†ÄÏû•.
        creep.memory[to_home] = []
        for r in creep.memory[to_pickup]:
            creep.memory[to_home].insert(0, r)

    if _.sum(creep.carry) == 0 and creep.memory.laboro != 0:
        creep.memory.laboro = 0
        creep.memory.priority = 0
        del creep.memory.last_swap

        if not creep.memory.build_target:
            # Î≥∏ÏßÑÏóê Î¨ºÍ±¥ Îã§ Ïò¨Î†∏ÏùÑÎïåÎßå Í∞ÄÎèô.
            # Ïª®ÌÖåÏù¥ÎÑàÏôÄ ÎßÅÌÅ¨ Îëò Îã§ Ï°¥Ïû¨ÌïòÎ©¥ Ï∫êÎ¶¨Ïñ¥Í∞Ä Ïª®ÌÖåÏù¥ÎÑàÏóê ÏûàÎäî ÏóêÎÑàÏßÄÎ•º ÎßÅÌÅ¨Ïóê ÏòÆÍ≤®ÎÑ£ÏùÑÏßÄ ÌôïÏù∏ÌïúÎã§.
            if creep.memory.container and creep.memory.link_target:
                # ÌÅ¨Î¶ΩÏóê Î¶¨ÌïÑÏûëÏóÖÏù¥ ÏÑ§Ï†ïÏù¥ ÏïàÎêòÏûàÎäîÍ∞Ä?
                if not creep.memory.refill:
                    creep.memory.refill = 1
                # ÌÅ¨Î¶ΩÏù¥ Î¶¨ÌïÑÏûëÏóÖÏùÑ ÏàòÌñâÏ§ëÏù¥ÏóàÎÇò? Í∑∏Îüº Îã§ ÌïúÍ±∏Î°ú ÏπúÎã§.
                elif creep.memory.refill == 1:
                    creep.memory.refill = 2
                # ÏóòÏä§Í∞Ä Í±∏Î¶∞Îã§Î©¥ refill == 2.
                # Î¶¨ÌïÑ Îã§ ÌïòÍ≥† Î¶¨Î™®Ìä∏ÏóêÏÑú ÏÉàÎ°ú Í∞ÄÏ†∏Ïò§ÎäîÏ§ëÏù¥ÏóàÎã®Í±∞. Î¶¨ÌïÑÌôïÏù∏Ìï¥ÏïºÌï®.
                else:
                    creep.memory.refill = 1
            # Ìï¥ÎãπÏÇ¨Ìï≠ ÏóÜÏúºÎ©¥ Î¶¨ÌïÑÏûëÏóÖ Ìï†ÌïÑÏöîÏóÜÏùå.
            else:
                creep.memory.refill = 0

        del creep.memory.build_target

    elif _.sum(creep.carry) >= creep.carryCapacity * .6 and creep.memory.laboro != 1:
        creep.memory.laboro = 1
        del creep.memory.last_swap

    if creep.memory.haul_target and not Game.getObjectById(creep.memory.haul_target):
        del creep.memory.haul_target

    # laboro: 0 == pickup something.
    if creep.memory.laboro == 0:
        # Ïö¥ÏÜ° ÏãúÏûëÌï† Ïãú Ïª®ÌÖåÏù¥ÎÑàÏóê ÏûêÏõêÏù¥ ÏûàÍ≥† Í∑ºÏ≤ò Ìï†ÎãπÎêú ÎßÅÌÅ¨Í∞Ä ÍΩâ ÏïàÏ∞∏? Í∑∏Îüº Ïª®ÌÖåÏù¥ÎÑàÏóêÏÑú ÎßÅÌÅ¨Î°ú ÏòÆÍ∏¥Îã§.
        # memory.refill Î°ú ÌôïÏù∏ÌïúÎã§ 0Ïù¥Î©¥ Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä ÏïÑÏòàÏóÜÎäîÍ±∞, 1Ïù¥Î©¥ ÌôïÏù∏Ìï¥ÏïºÌï®. 2Î©¥ Ïù¥ÎØ∏ ÌôïÏù∏Ìï®.
        # ÌôïÏù∏ÏùÑ ÏïÑÏßÅ ÏïàÌñàÍ≥† ÌÅ¨Î¶ΩÏù¥ Î≥∏ÏßÑÏù¥Î©∞, ÎßÅÌÅ¨ IDÎ•º Ï†ÄÏû•Ìï¥ÎëêÍ≥† ÏûàÎäîÍ∞Ä?
        if creep.memory.refill == 1 and creep.room.name == creep.memory.home_room \
                and creep.memory.link_target:
            # ÏãúÏûëÏ†Ñ Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏.
            if creep.memory.container and not Game.getObjectById(creep.memory.container):
                del creep.memory.container

            # ÎßÅÌÅ¨ÏïàÏóê ÏóêÎÑàÏßÄÍ∞Ä ÍΩâ Ï∞¨ ÏÉÅÌÉúÎ©¥ Ïñ¥Ï∞®Ìîº Î™ªÏ±ÑÏö∞Îãà ÎÅù.
            if Game.getObjectById(creep.memory.link_target).energyCapacity == \
                    Game.getObjectById(creep.memory.link_target).energy:
                creep.memory.refill = 2
            # Ï†ÄÏû•Îêú Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä ÏóÜÏúºÎ©¥ Ïù¥Í±∏ ÎèåÎ¶¥ Ïù¥Ïú†Í∞Ä ÏóÜÏùå.
            elif not creep.memory.container:
                creep.memory.refill = 0
            # ÎßåÏùº Ïª®ÌÖåÏù¥ÎÑàÏóê ÎÇ¥Ïö©Î¨ºÏù¥ ÎÇ®ÏïÑÏûàÏúºÎ©¥ ÏûëÏóÖÏãúÏûë.
            elif Game.getObjectById(creep.memory.container).store[RESOURCE_ENERGY] > 0:
                grab = grab_energy(creep, creep.memory.container, True, 0)
                creep.say("refill {}".format(grab))
                # Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä ÏóÜÏúºÎ©¥ ÌÜµÍ≥º.
                if grab == ERR_INVALID_TARGET:
                    del creep.memory.container
                    creep.memory.refill = 0
                # ÏóêÎÑàÏßÄÍ∞Ä ÏóÜÏúºÎ©¥ ÌÜµÍ≥º.
                elif grab == ERR_NOT_ENOUGH_ENERGY:
                    creep.memory.refill = 2
                # Îñ®Ïñ¥Ï†∏ ÏûàÏúºÎ©¥ ÎãπÏó∞ Îã§Í∞ÄÍ∞ÑÎã§.
                elif grab == ERR_NOT_IN_RANGE:
                    movement.movi(creep, creep.memory.container)
                # Ïò®Ï†ÑÌûà Ïû°ÏïòÏúºÎ©¥ Îã§ Ïû°ÏùÄÍ±∞ÎßàÎÉ• ÌñâÎèôÌïúÎã§. ÎßÅÌÅ¨Î°ú ÏòÆÍ∏∞Í∏∞ ÏúÑÌïú Ï†àÏ∞®.
                elif grab == OK:
                    creep.memory.laboro = 1
                    creep.memory.priority = 2
                    del creep.memory.last_swap
                return
            else:
                creep.memory.refill = 2

        # if there is a dropped target and it's there.
        if creep.memory.dropped:
            item_pickup_res = pick_drops(creep, True)
            item = Game.getObjectById(creep.memory.dropped)
            if item_pickup_res == ERR_INVALID_TARGET:
                creep.say("ÏÇêÎπÖ, ÏóÜÏùå", True)
                del creep.memory.dropped
            # ÎÇ¥Ïö©Î¨º ÏóÜÏùå
            elif item_pickup_res == ERR_NOT_ENOUGH_ENERGY:
                creep.say("üí¢ ÌÖÖ ÎπÑÏóàÏûñÏïÑ!", True)
                del creep.memory.dropped
            # Î©ÄÎ¶¨ÏûàÏùå
            elif item_pickup_res == ERR_NOT_IN_RANGE:
                movi(creep, creep.memory.dropped, 0, 10, False, 2000, '#0000FF')

            elif item_pickup_res == OK:
                creep.say('‚ôª‚ôª‚ôª', True)
                return

        # if there's no dropped and there's dropped_all
        if creep.memory.age > 50 and not creep.memory.dropped and len(dropped_all) > 0:
            for drop in dropped_all:
                # carrier will only take energy
                # ÌÅ¨Î¶ΩÏ†ïÎ≥¥ ÏûàÏúºÎ©¥ ÎπÑÏÑù.
                if drop.creep and not drop.store[RESOURCE_ENERGY]:
                    continue
                elif drop.resourceType != RESOURCE_ENERGY:
                    continue

                creep.memory.dropped = drop['id']

                item_pickup_res = pick_drops(creep, True)
                creep.say('‚õèBITCOINS!', True)
                if item_pickup_res == ERR_NOT_IN_RANGE:
                    movi(creep, creep.memory.dropped, 0, 10, False, 2000, '#0000FF')
                elif item_pickup_res == OK:
                    pass
                else:
                    creep.say('drpERR {}'.format(item_pickup_res))

                break
            #     # # if there's a dropped resources near 5
            #     # if creep.pos.inRangeTo(drop, 5):
            #     #     creep.memory.dropped = drop['id']
            #     #     creep.say('‚õèBITCOINS!', True)
            #     #     break
            # ********************************
            # if not item:
            #     creep.say('')
            #     del creep.memory.dropped
            #     return
            # # if the target is a tombstone
            # if item.creep:
            #     if _.sum(item.store) == 0:
            #         creep.say("üí¢ ÌÖÖ ÎπÑÏóàÏûñÏïÑ!", True)
            #         del creep.memory.dropped
            #         return
            #     # for resource in Object.keys(item.store):
            #     grab = grab_energy(creep, creep.memory.dropped, False, 0)
            # else:
            #     grab = creep.pickup(item)
            #
            # if grab == 0:
            #     del creep.memory.dropped
            #     creep.say('‚ôª‚ôª‚ôª', True)
            # elif grab == ERR_NOT_IN_RANGE:
            #     creep.moveTo(item,
            #                  {'visualizePathStyle': {'stroke': '#0000FF', 'opacity': .25},
            #                   'reusePath': 10})
            #     return
            # # if target's not there, go.
            # elif grab == ERR_INVALID_TARGET:
            #     del creep.memory.dropped
            #     for drop in dropped_all:
            #         # if there's a dropped resources near 5
            #         if creep.pos.inRangeTo(drop, 5):
            #             creep.memory.dropped = dropped_all['id']

        # if there's pickup, no need to go through all them below.
        # creep.memory.pickup == id of the container carrier's gonna pick up
        if creep.memory.pickup:
            # todo ÏõÄÏßÅÏù¥Îäî Î£®Ìä∏Î•º ÏôÑÏ†ÑÌûà Î©îÎ™®Î¶¨Ïóê ÎÑ£ÎäîÎã§.
            # Ïù¥Îïå Ìï¥ÏïºÌïòÎäî Î≥ÄÏàòÎäî ÌÅ¨Í≤å ÎëêÍ∞ÄÏßÄ.
            # Ï§ëÍ∞ÑÏóê Îñ®Í∂àÏßÑ Î¨ºÍ±¥Ïù¥ ÏûàÏñ¥ÏÑú Ï£ºÏõåÏïº Ìï¥ÏÑú Í≤ΩÎ°úÏù¥ÌÉà, ÎèåÏïÑÏò§ÎäîÍ∏∏Ïóê Ïª®ÌÖåÏù¥ÎÑàÎûë Í∏∏Ïù¥ ÏóÜÎäîÍ≤ΩÏö∞.

            # 1. if 1 == False, look for storage|containers to get the energy from.
            # 2. if 2 == False, you harvest on ur own.
            # result = grab_energy(creep, creep.memory.pickup, False, 0.0)
            result = grab_energy_new(creep)

            # *******************************************************************
            if result == ERR_NOT_IN_RANGE:
                path_array = \
                    _.map(creep.memory[to_pickup],
                          lambda p: __new__(RoomPosition(p.x, p.y, p.roomName)))
                # for i in creep.memory[to_pickup]:
                #     path_array.append(__new__(RoomPosition(i.x, i.y, i.roomName)))
                moving = creep.moveByPath(path_array)

                if moving == OK:
                    draw_path(creep, path_array)
                    check_loc_and_swap_if_needed(creep, creeps)
                # ÌÅ¨Î¶ΩÏúÑÏπòÍ∞Ä Í∏∏Í≥º ÏïàÎßûÎäî Í≤ΩÏö∞.
                elif moving == ERR_NOT_FOUND:
                    # path_array = []
                    # for i in creep.memory[to_pickup]:
                    #     __new__(RoomPosition)
                    # Í∞ÄÏû• Í∞ÄÍπåÏù¥ ÏûàÎäî Í∏∏ÏùÑ Ï∞æÏïÑÎÇòÏÑ†Îã§.
                    closest = creep.pos.findClosestByRange(path_array)
                    print(JSON.stringify(closest))
                    creep.say('ÌÉàÏÑ†x{}y{}'.format(closest.x, closest.y))
                    movi(creep, closest)
                else:
                    creep.say('ERR {}'.format(moving))

                # creep.moveTo(Game.getObjectById(creep.memory.pickup),
                #              {'visualizePathStyle': {'stroke': '#ffffff'}, 'reusePath': 25})
            elif result == 0:
                creep.say('BEEP BEEP‚õü', True)
                # Ïª®ÌÖåÏù¥ÎÑà ÏïàÏóê ÏóêÎÑàÏßÄ Ïô∏ Îã§Î•∏Í≤å Îì§Ïñ¥Í∞Ä ÏûàÏúºÎ©¥ ÎπºÎÇ¥ ÏóÜÏï†Ïïº ÌïòÍ∏∞Ïóê Ìïú Ï°∞Ïπò.
                if (len(Game.getObjectById(creep.memory.pickup).store) == 2
                        and Game.getObjectById(creep.memory.pickup).store[RESOURCE_ENERGY] == 0) \
                        or len(Game.getObjectById(creep.memory.pickup).store) == 1:
                    creep.memory.laboro = 1
                    del creep.memory.last_swap

                    if creep.memory.container_full:
                        creep.memory.container_full = 0
                        creep.memory.priority = 2
                    else:
                        creep.memory.priority = 0
            elif result == ERR_NOT_ENOUGH_ENERGY:
                if _.sum(creep.carry) > creep.carryCapacity * .4:
                    creep.memory.laboro = 1
                    creep.memory.priority = 0
                    del creep.memory.last_swap

                else:
                    harvest = creep.harvest(Game.getObjectById(creep.memory.source_num))
                    # creep.say('harv {}'.format(harvest))
                    if harvest == ERR_NOT_IN_RANGE:
                        creep.moveTo(Game.getObjectById(creep.memory.source_num),
                                     {'visualizePathStyle': {'stroke': '#ffffff'},
                                      'reusePath': 25})
                    # ÏûêÏõê Ï∫òÏàòÍ∞Ä ÏóÜÏúºÎ©¥ ÏûêÏõê Ï±ÑÏõåÏßàÎïåÍπåÏßÄ Ïª®ÌÖåÏù¥ÎÑà ÏúÑÏπòÏóêÏÑú ÎåÄÍ∏∞ÌÉÑÎã§.
                    elif harvest == ERR_NO_BODYPART or harvest == ERR_NOT_ENOUGH_RESOURCES:
                        if not creep.pos.isNearTo(Game.getObjectById(creep.memory.pickup)):
                            creep.moveTo(Game.getObjectById(creep.memory.pickup)
                                         , {'visualizePathStyle': {'stroke': '#ffffff'}, 'reusePath': 25})
                return
            # ÌååÍ¥¥ÎêòÍ±∞ÎÇò ÌïòÎ©¥ Î©îÎ™®Î¶¨ ÏÇ≠Ï†ú.
            elif result == ERR_INVALID_TARGET:
                del creep.memory.pickup
            # other errors? just delete 'em
            else:
                print(creep.name, 'grab_energy() ELSE ERROR:', result)
                del creep.memory.pickup
            return

        # no pickup target? then it's a start!
        else:
            # Î∞©Ïù¥ ÏïàÎ≥¥Ïù¥Í±∞ÎÇò ÌÅ¨Î¶ΩÏù¥ ÏûêÏõêÍ≥º Îñ®Ïñ¥Ï†∏ÏûàÏùÑ Í≤ΩÏö∞.
            if not Game.rooms[creep.memory.assigned_room]\
                    or not creep.pos.inRangeTo(Game.getObjectById(creep.memory.source_num), 5):
                # get_to_da_room(creep, creep.memory.assigned_room, False)
                # Ïä§Ìè∞Îê†Îïå ÏûêÎèôÏúºÎ°ú ÌòÑÏúÑÏπòÏóêÏÑú Í∏∏Ïù¥ Î∞∞Ï†ïÎêòÍ∏∞ ÎïåÎ¨∏Ïóê ÏóÜÏúºÎ©¥ Ïï†Ï¥àÎ∂ÄÌÑ∞ ÏûòÎ™ª Ïä§Ìè∞ÎêúÍ±∞.

                path_array = \
                    _.map(creep.memory[to_pickup],
                          lambda p: __new__(RoomPosition(p.x, p.y, p.roomName)))

                moving = creep.moveByPath(path_array)

                if moving == OK:
                    draw_path(creep, creep.memory[to_pickup])
                    check_loc_and_swap_if_needed(creep, creeps, False, False, creep.memory[to_pickup])
                # ÌÅ¨Î¶ΩÏúÑÏπòÍ∞Ä Í∏∏Í≥º ÏïàÎßûÎäî Í≤ΩÏö∞.
                elif moving == ERR_NOT_FOUND:
                    # Í∞ÄÏû• Í∞ÄÍπåÏù¥ ÏûàÎäî Í∏∏ÏùÑ Ï∞æÏïÑÎÇòÏÑ†Îã§.
                    draw_path(creep, creep.memory[to_pickup], 'red')
                    move = movi(creep, creep.pos.findClosestByRange(path_array))
                    creep.say('ÌîΩÏóÖÌÉàÏÑ†:{}'.format(move))
                else:
                    creep.say('ERR {}'.format(moving))

                return

            # Ïó¨Í∏∞Î°ú ÏôîÎã§ÎäîÍ±¥ Ìï†Îãπ Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä ÏóÜÎã§Îäî ÏÜåÎ¶¨. ÌïúÎßàÎîîÎ°ú not creep.memory.pickup == True
            # ÏàòÏ†ï:
            # Ïù¥Í≤å Îú®Î©¥ Î¨¥Ï°∞Í±¥ Î®ºÏ†∏ Îã¥ÎãπÍµ¨Ïó≠ÏúºÎ°ú Í∞ÑÎã§. Í∞Ñ ÌõÑ Îã¥Îãπ Î¶¨ÏÜåÏä§Î•º ÌôïÏù∏ÌïúÎã§.(Ïù¥Í±¥ Ïä§Ìè∞ Ïãú ÏûêÎèô)
            # Í∑∏ ÌõÑÏóê Î∞∞Ï†ïÎ∞õÏùÄ ÌîΩÏóÖÏù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏ÌïúÎã§.
            # Î∞∞Ï†ïÎ∞õÏùÄ ÌîΩÏóÖÏù¥ Ï°¥Ïû¨ÌïòÎ©¥ Í∑∏Í±∏Î°ú ÎÅù. ÏóÜÏúºÎ©¥ Í±¥ÏÑ§Îã¥ÎãπÏù∏ ÏÖà. ÏûêÏõê Ï∫îÎã§.

            # pickupÏù¥ ÏóÜÏúºÎãà ÏûêÏõêÏ∫êÎü¨ Í∞ÑÎã§.
            harvest = harvest_energy(creep, creep.memory.source_num)
            # print(creep.name, 'harvest', harvest)
            if harvest == ERR_NOT_IN_RANGE:
                creep.moveTo(Game.getObjectById(creep.memory.source_num)
                             , {'visualizePathStyle': {'stroke': '#ffffff'}, 'reusePath': 25})
            # Ïª®ÌÖåÏù¥ÎÑà Í±¥ÏÑ§ÏùÑ Ìï¥Ïïº ÌïòÎäîÎç∞ ÏùºÏùÑ Î™ªÌïòÎäî ÎÜàÏù¥Î©¥ Ï£ΩÏñ¥Îùº.
            elif harvest == ERR_NO_BODYPART:
                creep.suicide()
                return
            else:
                creep.say('hrvst {}'.format(harvest))

            # Îß§ Ìã±ÎßàÎã§ ÌîΩÏóÖÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïúÎã§. ÏûàÏúºÎ©¥ Î∞îÎ°ú Îì±Î°ù.
            # Í∞ôÏùÄ Î∞©ÏùºÎïåÎßå ÌôïÏù∏ÌïúÎã§.
            if creep.room.name == Game.rooms[creep.memory.assigned_room].name:
                for s in all_structures:
                    if s.structureType == STRUCTURE_CONTAINER:
                        if Game.getObjectById(creep.memory.source_num).pos.inRangeTo(s, 3):
                            creep.memory.pickup = s.id

    # getting to work.
    elif creep.memory.laboro == 1:
        # PRIORITY
        # 1. if there's something to construct, do that first.
        # 2. else, carry energy or whatever to the nearest link of the home_room
        # 3. repair

        if creep.memory.priority == 0:

            # made for cases carriers dont have WORK
            creep_body_has_work = creep.memory.work

            try:
                # construction sites. only find if creep is not in its flag location.
                if creep.room.name != creep.memory.assigned_room:
                    constructions = Game.rooms[creep.memory.assigned_room].find(FIND_MY_CONSTRUCTION_SITES)
            except:
                # Ïù¥Í≤å Í±∏Î¶¨Î©¥ ÏßÄÍ∏à Î∞òÎåÄÏ™Ω Î∞©Ïóê ÏïÑÎ¨¥Í≤ÉÎèÑ ÏóÜÏñ¥ÏÑú ÏãúÏïºÌôïÎ≥¥ ÏïàÎêêÎã® ÏÜåÎ¶¨.
                return
            # if there's no WORK in carrier they cant do fix or build at all.
            if not creep_body_has_work:
                creep.say('üîÑÎ¨ºÎ•ò,ÏóºÎ†§ÎßêÎùº!', True)
                creep.memory.priority = 2
            elif len(constructions) > 0:
                creep.say('üöß Í±¥ÏÑ§Ìà¨ÏüÅ!', True)
                creep.memory.priority = 1
            else:
                # ÏàòÎ¶¨Ìï† Í≤ÉÏù¥ ÏûàÎäîÍ∞Ä? ÏûàÏúºÎ©¥ ÌôïÎ•† Î∞úÎèô. ÏóÜÏúºÎ©¥ 1 Í≥†Ï†ï. 20% Ïù¥Ìïò Ï≤¥Î†•Í±¥Î¨ºÏù¥ ÏûàÏúºÎ©¥ 100%
                # Ïù¥Ï†ú ÏûàÏùÑÎïåÎßå Ï†ÅÏö©.
                if len(repairs) > 0:
                    random_chance = 1
                    if creep.memory.pickup:
                        pick_obj = Game.getObjectById(creep.memory.pickup)
                        if pick_obj and pick_obj.pos.inRangeTo(creep, 3):
                            if pick_obj.hits <= pick_obj.hitsMax * .6:
                                random_chance = 0
                        # for repair in repairs:
                        #     if Game.getObjectById(creep.memory.pickup).pos.inRangeTo(repair, 3):
                        #         if repair.hits <= repair.hitsMax * .6:
                        #             random_chance = 0
                        #             break
                else:
                    random_chance = random.randint(0, 10)

                if random_chance != 0:
                    creep.say('üîÑÎ¨ºÎ•ò,ÏóºÎ†§ÎßêÎùº!', True)
                    creep.memory.priority = 2
                # 9% ÌôïÎ•†Î°ú Î∞úÎèôÌï®.
                else:
                    creep.say('üîßREGULAR‚úî‚¨Ü', True)
                    creep.memory.priority = 3

        # PRIORITY 1: construct
        if creep.memory.priority == 1:
            if not creep.memory.work:
                creep.memory.priority = 2
                creep.say('Í±¥ÏÑ§Î™ªÌï® „Ö†„Ö†', True)
                return

            try:
                # dont have a build_target and not in proper room - get there firsthand.
                if creep.memory.assigned_room != creep.room.name and not creep.memory.build_target:
                    # constructions = Game.flags[creep.memory.flag_name].room.find(FIND_CONSTRUCTION_SITES)
                    # print('?', constructions)
                    get_to_da_room(creep, creep.memory.assigned_room, False)
                    # creep.moveTo(Game.flags[creep.memory.flag_name], {'visualizePathStyle': {'stroke': '#ffffff'}
                    #     , 'reusePath': 25})
                    return
            except:
                print('no visual in room {}'.format(creep.memory.assigned_room))
                return

            # print('construction:', construction)
            if not creep.memory.build_target:
                construction = creep.pos.findClosestByRange(constructions)
                if not construction:
                    creep.memory.priority = 0
                    creep.memory.laboro = 0
                    del creep.memory.last_swap
                    return
                creep.memory.build_target = construction.id

            build_result = creep.build(Game.getObjectById(creep.memory.build_target))  # construction)
            creep.say(build_result)
            # print('build_result:', build_result)
            if build_result == ERR_NOT_IN_RANGE:
                move_res = creep.moveTo(Game.getObjectById(creep.memory.build_target)
                                        , {'visualizePathStyle': {'stroke': '#ffffff'}, 'reusePath': 10, 'range': 3})
                # print('move_res:', move_res)
            # if there's nothing to build or something
            elif build_result == ERR_INVALID_TARGET:
                # if there's no more construction sites, get back grabbing energy.
                if len(constructions) == 0 and _.sum(creep.carry) >= creep.carryCapacity * .6:
                    # print(creep.name, 'con', 11)
                    creep.memory.priority = 2
                    del creep.memory.build_target
                elif len(constructions) == 0:
                    # print(creep.name, 'con', 22)
                    creep.memory.priority = 0
                    creep.memory.laboro = 0
                    del creep.memory.last_swap
                    del creep.memory.build_target
                # if there are more, return to priority 0 to decide what to do.
                else:
                    # print(creep.name, 'con', 33)
                    creep.memory.priority = 0
                    del creep.memory.build_target
            elif build_result == ERR_NO_BODYPART:
                creep.memory.priority = 2
                creep.say('Í±¥ÏÑ§Î™ªÌï®..', True)
                return

        # PRIORITY 2: carry 'em
        elif creep.memory.priority == 2:

            if len(repairs) > 0 and creep.memory.work:
                repair_on_the_way(creep, repairs, constructions, False, True)

            # Ïö∞ÏÑ† Î¨¥ÏûëÏ†ï Î≥∏ÏßÑÏúºÎ°ú Í∞ÑÎã§. ÏßÄÏ†ïÎêú Í∏∏ Ïù¥Ïö©ÌïòÎ©¥ Îê®.
            if not creep.room.name == creep.memory[home_room]:
                home_arr = []
                for i in creep.memory[to_home]:
                    # print('i.x, i.y, i.roomName {} {} {}'.format(i.x, i.y, i.roomName))
                    home_arr.append(__new__(RoomPosition(i.x, i.y, i.roomName)))
                go_home = creep.moveByPath(home_arr)
                if go_home == OK:
                    draw_path(creep, home_arr)
                    check_loc_and_swap_if_needed(creep, creeps, False, False, home_arr)
                    # ÌÅ¨Î¶ΩÏúÑÏπòÍ∞Ä Í∏∏Í≥º ÏïàÎßûÎäî Í≤ΩÏö∞.
                elif go_home == ERR_NOT_FOUND:
                    # Í∞ÄÏû• Í∞ÄÍπåÏù¥ ÏûàÎäî Í∏∏ÏùÑ Ï∞æÏïÑÎÇòÏÑ†Îã§.

                    move = movi(creep, creep.pos.findClosestByRange(home_arr))
                    creep.say('Ïßë ÌÉàÏÑ†:{}'.format(move))
                else:
                    creep.say('ERR {}'.format(go_home))
            # Î≥∏ÏßÑÎèÑÏ∞©
            else:
                # Î∞∞Ï†ïÎêú Î™©ÌëúÏßÄÍ∞Ä ÏûàÎäîÍ∞Ä?
                if not creep.memory.haul_target:
                    # Ï∫êÎ¶¨Ïñ¥Í∞Ä ÎÅåÍ≥†Í∞à Ïàò ÏûàÎäî Î™©ÌëúÎ¨ºÎì§
                    haul_target_objs = []
                    # Ï†ÑÏÜ°Ïö© ÎßÅÌÅ¨
                    for l in creep.room.memory[STRUCTURE_LINK]:
                        if not l[for_store]:
                            haul_target_objs.append(Game.getObjectById(l.id))
                    # Î™®Îì† Ïª®ÌÖåÏù¥ÎÑà.
                    for c in creep.room.memory[STRUCTURE_CONTAINER]:
                        haul_target_objs.append(Game.getObjectById(l.id))
                    # Ïä§ÌÜ†Î¶¨ÏßÄ
                    if creep.room.storage:
                        haul_target_objs.append(creep.room.storage)

                    link_or_container = creep.pos.findClosestByRange(haul_target_objs)
                    creep.memory.haul_target = link_or_container.id
                # Ïó¨Í∏∞ÍπåÏßÄ ÏôîÎäîÎç∞ ÏóÜÏúºÎ©¥ Ï§ëÎåÄÌïú Ïò§Î•òÏûÑ.... ÎßêÎèÑÏïàÎêòÎäî ÏÜåÎ¶¨Í≥† ÏÜîÏßÅÌûà.
                if not creep.memory.haul_target:
                    creep.say('Î™©ÌëúÍ∞ÄÏóÜÎã§!')
                    return
                # Ïù¥Ï†ú Îã§Í∞ÄÍ∞ÄÎäîÍ±∞.
                if creep.pos.isNearTo(Game.getObjectById(creep.memory.haul_target)):
                    if creep.carry[RESOURCE_ENERGY] == 0:
                        transfer_result = ERR_NOT_ENOUGH_ENERGY
                    else:
                        transfer_result = creep.transfer(Game.getObjectById(creep.memory.haul_target),
                                                         RESOURCE_ENERGY)
                else:
                    transfer_result = ERR_NOT_IN_RANGE

                if transfer_result == ERR_NOT_IN_RANGE:
                    if creep.memory.err_full:
                        creep.memory.err_full = 0
                    move_using_swap(creep, creeps, creep.memory.haul_target)
                # if done, check if there's anything left. if there isn't then priority resets.
                elif transfer_result == ERR_INVALID_TARGET:
                    creep.memory.err_full = 0
                    creep.memory.priority = 0
                    del creep.memory.haul_target
                # Ïûò Îêú Í≤ΩÏö∞
                elif transfer_result == OK:
                    creep.memory.err_full = 0
                    # ÍµêÏ∞®Ïù¥ÎèôÌïú ÌÅ¨Î¶ΩÏù¥ ÏûàÏóàÏúºÎ©¥ Ï¥àÍ∏∞Ìôî
                    if creep.memory.last_swap:
                        del creep.memory.last_swap

                    if not creep.memory.refill and creep.memory.link_target and creep.memory.container:
                        creep.memory.refill = 1

                    # Ïù¥Îèô ÏôÑÎ£åÌñàÎäîÎç∞ ÌîΩÏóÖÎèÑÏóÜÍ≥† Í∑∏Î†áÎã§Í≥† ÏùºÌï†ÏàòÏûàÎäîÍ≤ÉÎèÑ ÏïÑÎãàÎ©¥ Ï£ΩÏñ¥ÏïºÌï®. ÌîÑÎ°†Ìã∞Ïñ¥Ïùº Í≤ΩÏö∞ÎèÑ Ìï¥Îãπ.
                    if (not Game.getObjectById(creep.memory.pickup) and not creep.memory.work) \
                            or creep.memory.frontier:
                        creep.suicide()
                        return
                    # ÏòÆÍ∏¥ ÎåÄÏÉÅÏù¥ ÎßÅÌÅ¨Ïù∏ÏßÄ? ÏïÑÎãàÎ©¥ ÎßÅÌÅ¨Î°ú ÍµêÏ≤¥.
                    elif not Game.getObjectById(creep.memory.haul_target).structureType == STRUCTURE_LINK:
                        if creep.memory.link_target and not Game.getObjectById(creep.memory.link_target):
                                del creep.memory.link_target
                        if creep.memory.container and not Game.getObjectById(creep.memory.container):
                                del creep.memory.container
                        # Ï∫êÎ¶¨Ïñ¥Îäî Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÎßÅÌÅ¨Î°ú Ïö¥ÏÜ°ÌïòÎäîÍ≤å ÏõêÏπô.
                        # haul_target Ïù¥ ÎßÅÌÅ¨Í∞Ä ÏïÑÎãàÎ©¥ Ï∞æÏïÑÏÑú Îì±Î°ùÌïúÎã§. ÏßÑÏßú ÏóÜÏúºÎ©¥... Í±ç ÏóÜÎäîÍ±∞...
                        if not creep.memory.link_target and not creep.memory.no_link:
                            links = []
                            for l in creep.room.memory[STRUCTURE_LINK]:
                                if not l[for_store]:
                                    links.append(Game.getObjectById(l.id))
                            if len(links) > 0:
                                # Í∞ÄÏû• Í∞ÄÍπåÏö¥Í±∞ Ï∞æÍ≥† 6Ïπ∏Ïù¥ÎÇ¥Ïóê ÏûàÏúºÎ©¥ ÏòÆÍ∏¥ÎåÄÏÉÅÏù¥ ÎßÅÌÅ¨Í∞Ä ÏïÑÎãê Í≤ΩÏö∞Î•º ÎåÄÎπÑÌïú ÏïÑÏù¥ÎîîÎ°ú Îì±Î°ù.
                                closest_obj = creep.pos.findClosestByPath(links)
                                if len(creep.room.findPath(creep.pos, closest_obj.pos,
                                                           {'ignoreCreeps': True})) <= 6:
                                    creep.memory.link_target = closest_obj.id
                                else:
                                    # ÌÅ¨Î¶Ω Ï£ºÎ≥ÄÏóê ÎßÅÌÅ¨Í∞Ä ÏóÜÎã§Îäî ÏÜåÎ¶¨. ÏúÑÏóê Î£®ÌîÑÎ¨∏ Îß§Î≤à Î∞òÎ≥µ ÏïàÌïòÍ∏∞ ÏúÑÌï¥ ÏÉùÏÑ±.
                                    creep.memory.no_link = 1

                            creep.memory.haul_target = creep.memory.link_target
                            # Îã§ÏùåÎ≤àÏóê ÏïàÏÑ∏Í≥† Î∞îÎ°ú Ïª®ÌÖåÏù¥ÎÑàÌñâÏù∏ÎìØ
                            creep.memory.err_full = 3
                    # ÎßÅÌÅ¨Í≥† Ïª®ÌÖåÏù¥ÎÑà Í∞ÄÏßÑÍ≤å ÏóÜÎäî Í≤ΩÏö∞ ÌïúÎ≤à Ï£ºÎ≥ÄÏóê Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä ÏûàÎÇò ÎëòÎü¨Î¥ÖÏãúÎã§
                    elif Game.getObjectById(creep.memory.haul_target).structureType == STRUCTURE_LINK \
                            and not creep.memory.container:
                        hr_containers = []
                        for c in creep.room.memory[STRUCTURE_CONTAINER]:
                            hr_containers.append(Game.getObjectById(c.id))

                        if len(hr_containers):
                            closest_cont = creep.pos.findClosestByPath(hr_containers, {ignoreCreeps: True})
                            if len(creep.room.findPath(creep.pos, closest_cont.pos,
                                                       {'ignoreCreeps': True})) <= 6:
                                creep.memory.container = closest_cont.id
                                check_for_carrier_setting(creep, Game.getObjectById(creep.memory.container))
                            else:
                                creep.memory.no_container = 1

                elif transfer_result == ERR_FULL:
                    if not creep.memory.err_full and not creep.memory.err_full == 0:
                        creep.memory.err_full = 0
                    creep.memory.err_full += 1
                    # Îã§ ÍΩâÏ∞ºÏúºÎ©¥ Ï¶âÍ∞Å ÍµêÏ≤¥. ÍµêÏ≤¥Îäî ÎßÅÌÅ¨Î•º Ïö∞ÏÑ†Ï†ÅÏúºÎ°ú ÌÉùÌïúÎã§.
                    if creep.memory.err_full > 1:
                        # ÍµêÏ≤¥Ìï† ÎåÄÏÉÅÏù¥ Ï°¥Ïû¨ÌïòÎäîÍ∞Ä?
                        switch_exists = False

                        # ÎßÅÌÅ¨Î•º Î®ºÏ†∏ Ï∞æÎäîÎã§.
                        links = []
                        for l in creep.room.memory[STRUCTURE_LINK]:
                            l_obj = Game.getObjectById(l.id)
                            #
                            if l_obj and not l[for_store] and l_obj.energy < l_obj.energyCapacity:
                                links.append(l_obj)
                        # Í∞ÄÏû• Í∞ÄÍπåÏù¥ ÏûàÎäîÍ≤å 6Ïπ∏Ïù¥ÎÇ¥?
                        closest_obj = creep.pos.findClosestByPath(links, {ignoreCreeps: True})
                        if closest_obj and len(closest_obj.pos.findPathTo(creep, {ignoreCreeps: True})) <= 6:
                            switch_exists = True
                            creep.memory.haul_target = closest_obj.id
                        # ÏóÜÏúºÎ©¥? Ïª®ÌÖåÏù¥ÎÑà ÎòêÎäî Ïä§ÌÜ†Î¶¨ÏßÄ Ï∞æÎäîÎã§, Ï†àÏ∞® ÏûêÏ≤¥Îäî ÏúÑÏôÄ ÎèôÏùº.
                        else:
                            home_obj = []
                            for c in creep.room.memory[STRUCTURE_CONTAINER]:
                                c_obj = Game.getObjectById(c.id)
                                if c_obj and _.sum(c_obj.store) < c_obj.storeCapacity:
                                    home_obj.append(c_obj)
                            if creep.room.storage:
                                home_obj.append(creep.room.storage)

                            closest_obj = creep.pos.findClosestByPath(home_obj, {ignoreCreeps: True})
                            if closest_obj and len(closest_obj.pos.findPathTo(creep, {ignoreCreeps: True})) <= 6:
                                switch_exists = True
                                creep.memory.haul_target = closest_obj.id

                        if not switch_exists:
                            creep.memory.err_full = -10
                            creep.say('ÍΩâÏ∞∏...{}'.format(creep.memory.err_full))
                    else:
                        creep.say('ÍΩâÏ∞∏...{}'.format(creep.memory.err_full))
                # ÏóêÎÑàÏßÄ Ïô∏ Îã§Î•∏Í≤å ÏûàÎäî ÏÉÅÌô©. Ïù¥ Í≤ΩÏö∞ Í∑∏ÎÉ• Îã§ Îñ®Íµ∞Îã§.
                elif transfer_result == ERR_NOT_ENOUGH_ENERGY:
                    stores = creep.carry
                    # todo Îã§Îßå Ïª®ÌÖåÏù¥ÎÑàÎ©¥ Îã§Î•¥Í≤å.
                    # if Game.getObjectById(creep.memory.haul_target).structureType == STRUCTURE_CONTAINER:
                    #     for s in Object.keys(stores):
                    #         if s == RESOURCE_ENERGY:
                    #             continue
                    #         a = creep.drop(s)
                    #         break

                    for s in Object.keys(stores):
                        if s == RESOURCE_ENERGY:
                            continue
                        a = creep.drop(s)
                        break
                else:
                    creep.say('ERR {}'.format(transfer_result))

            # ----------------------------------------------------
            # NULLIFIED
            # # if you're not in the home_room and no haul_target
            # # Ïù¥Îüº Ïö∞ÏÑ† Ï≥ê Í∞ÑÎã§.
            # if creep.room.name != creep.memory.home_room and not creep.memory.haul_target:
            #     # at first it was to move to controller.
            #     # but somehow keep getting an error, so let's try
            #     if len(repairs) > 0 and creep.memory.work:
            #         # repair = creep.pos.findClosestByRange(repairs)
            #         # creep.repair(repair)
            #         repair_on_the_way(creep, repairs, constructions, False, True)
            #     go = get_to_da_room(creep, creep.memory.home_room, False)
            #     creep.say(go)
            #     return
            #
            # # todo ÏôÑÏ†ÑÌûà ÏÉàÎ°ú ÎßåÎì†Îã§. Ïì∏Îç∞ÏóÜÏù¥ Î≥µÏû°Ìï®.
            # # fixed container/link target to move to.
            # if not creep.memory.haul_target:
            #
            #
            #     # NULLIFIED
            #     # haul_target Ïù¥ ÏóÜÏùÑ Í≤ΩÏö∞ Ï†àÏ∞®Îäî ÌÅ¨Í≤å ÎëòÎ°ú ÎÇòÎâúÎã§.
            #     # 1. Ïö∞ÏÑ† Î∞©ÏúºÎ°ú Ï≥ê Í∞ÑÎã§
            #     # 2. Îã§ÏùåÏóê Í∞ÄÏû• Í∞ÄÍπåÏù¥ ÏûàÎäî ÎßÅÌÅ¨, ÏóÜÏúºÎ©¥ Ïª®ÌÖåÏù¥ÎÑà Î∞∞Ï†ï.
            #     # all_structures in the home room
            #     home_structures = Game.rooms[creep.memory.home_room].find(FIND_STRUCTURES)
            #     # find links outside the filter and containers
            #     outside_links_and_containers = \
            #         _.filter(all_structures,
            #                  lambda s: s.structureType == STRUCTURE_CONTAINER or s.structureType == STRUCTURE_STORAGE
            #                  or s.structureType == STRUCTURE_LINK)
            #
            #     link_or_container = creep.pos.findClosestByRange(outside_links_and_containers)
            #
            #     # Î©îÎ™®Î¶¨Î•º ÎúØÏñ¥ÏÑú Ï∫êÎ¶¨Ïñ¥Ïö©Ïù∏ÏßÄ ÎßàÌÇπÏùÑ ÌïúÎã§.
            #     if link_or_container.structureType == STRUCTURE_CONTAINER:
            #         creep.memory.container = link_or_container.id
            #         check_for_carrier_setting(creep, link_or_container)
            #     elif link_or_container.structureType == STRUCTURE_LINK:
            #         check_for_carrier_setting(creep, link_or_container)
            #
            #     creep.memory.haul_target = link_or_container.id
            # if creep.pos.isNearTo(Game.getObjectById(creep.memory.haul_target)):
            #     if creep.carry[RESOURCE_ENERGY] == 0:
            #         transfer_result = ERR_NOT_ENOUGH_ENERGY
            #     else:
            #         transfer_result = creep.transfer(Game.getObjectById(creep.memory.haul_target), RESOURCE_ENERGY)
            # else:
            #     transfer_result = ERR_NOT_IN_RANGE
            # if transfer_result == ERR_NOT_IN_RANGE:
            #     creep.memory.err_full = 0
            #     if len(repairs) > 0 and creep.memory.work:
            #         repair_on_the_way(creep, repairs, constructions, False, True)
            #         # repair = creep.pos.findClosestByRange(repairs)
            #         # creep.repair(repair)
            #     # ÏôÑÏ†Ñ ÎåÄÏ≤¥!
            #     move_using_swap(creep, creeps, creep.memory.haul_target)
            # # if done, check if there's anything left. if there isn't then priority resets.
            # elif transfer_result == ERR_INVALID_TARGET:
            #     creep.memory.err_full = 0
            #     creep.memory.priority = 0
            #     del creep.memory.haul_target
            # elif transfer_result == OK:
            #     creep.memory.err_full = 0
            #     # ÍµêÏ∞®Ïù¥ÎèôÌïú ÌÅ¨Î¶ΩÏù¥ ÏûàÏóàÏúºÎ©¥ Ï¥àÍ∏∞Ìôî
            #     if creep.memory.last_swap:
            #         del creep.memory.last_swap
            #
            #     if not creep.memory.refill and creep.memory.link_target and creep.memory.container:
            #         creep.memory.refill = 1
            #
            #     # Ïù¥Îèô ÏôÑÎ£åÌñàÎäîÎç∞ ÌîΩÏóÖÎèÑÏóÜÍ≥† Í∑∏Î†áÎã§Í≥† ÏùºÌï†ÏàòÏûàÎäîÍ≤ÉÎèÑ ÏïÑÎãàÎ©¥ Ï£ΩÏñ¥ÏïºÌï®.
            #     # ÌîÑÎ°†Ìã∞Ïñ¥Ïùº Í≤ΩÏö∞ÎèÑ Ìï¥Îãπ.
            #     if (not Game.getObjectById(creep.memory.pickup) and not creep.memory.work) \
            #             or creep.memory.frontier:
            #         creep.suicide()
            #         return
            #     # ÏòÆÍ∏¥ ÎåÄÏÉÅÏù¥ ÎßÅÌÅ¨Ïù∏ÏßÄ? ÏïÑÎãàÎ©¥ ÎßÅÌÅ¨Î°ú ÍµêÏ≤¥.
            #     elif not Game.getObjectById(creep.memory.haul_target).structureType == STRUCTURE_LINK:
            #         if creep.memory.link_target:
            #             if not Game.getObjectById(creep.memory.link_target):
            #                 del creep.memory.link_target
            #         if creep.memory.container:
            #             if not Game.getObjectById(creep.memory.container):
            #                 del creep.memory.container
            #         # Ï∫êÎ¶¨Ïñ¥Îäî Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÎßÅÌÅ¨Î°ú Ïö¥ÏÜ°ÌïòÎäîÍ≤å ÏõêÏπôÏù¥Îã§.
            #         # Î∞©Í∏à ÏòÆÍ∏¥ ÎåÄÏÉÅÍ±¥Î¨ºÏù¥ ÎßÅÌÅ¨Í∞Ä ÏïÑÎãàÎ©¥ Ï∞æÏïÑÏÑú Îì±Î°ùÌïúÎã§. ÏßÑÏßú ÏóÜÏúºÎ©¥... Í±ç ÏóÜÎäîÍ±∞...
            #         if not creep.memory.link_target and not creep.memory.no_link:
            #             links = _.filter(all_structures,
            #                              lambda s: s.structureType == STRUCTURE_LINK)
            #             # Î∞© ÏïàÏóê ÎßÅÌÅ¨Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏.
            #             if len(links) > 0:
            #                 # ÏûàÏúºÎ©¥ Í∞ÄÏû• Í∞ÄÍπåÏö¥Í±∞ Ï∞æÍ≥† Í∑∏Í≤å 6Ïπ∏Ïù¥ÎÇ¥Ïóê ÏûàÏúºÎ©¥
            #                 # Ï∂îÌõÑ ÏòÆÍ∏¥ÎåÄÏÉÅÏù¥ ÎßÅÌÅ¨Í∞Ä ÏïÑÎãê Í≤ΩÏö∞Î•º ÎåÄÎπÑÌïú ÏïÑÏù¥ÎîîÎ°ú Îì±Î°ùÌïúÎã§.
            #                 closest_obj = creep.pos.findClosestByPath(links)
            #                 if len(creep.room.findPath(creep.pos, closest_obj.pos,
            #                                            {'ignoreCreeps': True})) <= 6:
            #                     creep.memory.link_target = closest_obj.id
            #                     check_for_carrier_setting(creep, Game.getObjectById(creep.memory.link_target))
            #                 else:
            #                     # ÌÅ¨Î¶Ω Ï£ºÎ≥ÄÏóê ÎßÅÌÅ¨Í∞Ä ÏóÜÎã§Îäî ÏÜåÎ¶¨. ÏúÑÏóê Î£®ÌîÑÎ¨∏ Îß§Î≤à Î∞òÎ≥µ ÏïàÌïòÍ∏∞ ÏúÑÌï¥ ÏÉùÏÑ±.
            #                     creep.memory.no_link = 1
            #         creep.memory.haul_target = creep.memory.link_target
            #         # Îã§ÏùåÎ≤àÏóê ÏïàÏÑ∏Í≥† Î∞îÎ°ú Ïª®ÌÖåÏù¥ÎÑàÌñâÏù∏ÎìØ
            #         creep.memory.err_full = 3
            #     # ÎßÅÌÅ¨Ïùº Í≤ΩÏö∞ ÌïúÎ≤à Ï£ºÎ≥ÄÏóê Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä ÏûàÎÇò ÎëòÎü¨Î¥ÖÏãúÎã§
            #     elif Game.getObjectById(creep.memory.haul_target).structureType == STRUCTURE_LINK:
            #         # Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä ÏûàÏúºÎ©¥ ÌÜµÍ≥º.
            #         if creep.memory.container:
            #             pass
            #         # ÏóÜÏúºÎ©¥ Ï∞æÏïÑÎ≥¥Í∏∞. Î∞©Î≤ïÏùÄ ÏúÑÏóê Ïª®ÌÖåÏù¥ÎÑàÏùºÎïå Ï∞æÎäî Ï†àÏ∞®ÏôÄ ÎèôÏùºÌïòÎã§.
            #         elif not creep.memory.no_container:
            #             hr_containers = _.filter(all_structures,
            #                                      lambda s: s.structureType == STRUCTURE_CONTAINER)
            #             # Ïª®ÌÖåÏù¥ÎÑà Î™ªÏ∞æÏïòÏúºÎ©¥ Îã§ÏùåÏóê Îòê Î¨¥ÏùòÎØ∏ÌïòÍ≤å Ï∞æÏùÑÌïÑÏöî ÏóÜÏúºÎãà.
            #             checked_alt_cont = False
            #             if len(hr_containers):
            #                 closest_cont = creep.pos.findClosestByPath(hr_containers)
            #                 if len(creep.room.findPath(creep.pos, closest_cont.pos,
            #                                            {'ignoreCreeps': True})) <= 6:
            #                     checked_alt_cont = True
            #                     creep.memory.container = closest_cont.id
            #                     check_for_carrier_setting(creep, Game.getObjectById(creep.memory.container))
            #             if not checked_alt_cont:
            #                 creep.memory.no_container = 1
            # # only happens inside the home room
            # elif transfer_result == ERR_FULL:
            #     if not creep.memory.err_full and not creep.memory.err_full == 0:
            #         creep.memory.err_full = 0
            #     creep.memory.err_full += 1
            #
            #     # Îã§ ÍΩâÏ∞ºÏúºÎ©¥ Ï¶âÍ∞Å ÍµêÏ≤¥
            #     # ÍµêÏ≤¥Îäî ÎßÅÌÅ¨Î•º Ïö∞ÏÑ†Ï†ÅÏúºÎ°ú ÌÉùÌïúÎã§.
            #     if creep.memory.err_full > 1:
            #         # ÍµêÏ≤¥Ìï† ÎåÄÏÉÅÏù¥ Ï°¥Ïû¨ÌïòÎäîÍ∞Ä?
            #         switch_exists = False
            #
            #         # ÎßÅÌÅ¨Î•º Î®ºÏ†∏ Ï∞æÎäîÎã§.
            #         home_obj = \
            #             _.filter(all_structures,
            #                      lambda s: s.structureType == STRUCTURE_LINK and s.energy < s.energyCapacity)
            #         # Í∞ÄÏû• Í∞ÄÍπåÏù¥ ÏûàÎäî ÎßÅÌÅ¨
            #         closest_obj = creep.pos.findClosestByPath(home_obj, {ignoreCreeps: True})
            #         # 5Ïπ∏ Ïù¥ÎÇ¥Ïù∏Í±∞Îßå Ïû°ÎäîÎã§.
            #         if closest_obj and len(closest_obj.pos.findPathTo(creep, {ignoreCreeps: True})) <= 5:
            #             switch_exists = True
            #             creep.memory.haul_target = closest_obj.id
            #             check_for_carrier_setting(creep, closest_obj)
            #         # ÏóÜÏúºÎ©¥? Ïª®ÌÖåÏù¥ÎÑà ÎòêÎäî Ïä§ÌÜ†Î¶¨ÏßÄ Ï∞æÎäîÎã§.
            #         else:
            #             # ÏúÑÏôÄ Ï†àÏ∞® ÏûêÏ≤¥Îäî ÎèôÏùºÌïòÎã§.
            #             home_obj = \
            #                 _.filter(all_structures,
            #                          lambda s: (s.structureType == STRUCTURE_CONTAINER
            #                                     and _.sum(s.store) < s.storeCapacity)
            #                                    or s.structureType == STRUCTURE_STORAGE)
            #
            #             closest_obj = creep.pos.findClosestByPath(home_obj, {ignoreCreeps: True})
            #             if closest_obj and len(closest_obj.pos.findPathTo(creep, {ignoreCreeps: True})) <= 5:
            #                 switch_exists = True
            #                 creep.memory.haul_target = closest_obj.id
            #                 if closest_obj.structureType == STRUCTURE_CONTAINER:
            #                     creep.memory.container = closest_obj.id
            #                     check_for_carrier_setting(creep, closest_obj)
            #
            #         if not switch_exists:
            #             creep.memory.err_full = -10
            #             creep.say('ÍΩâÏ∞∏...{}'.format(creep.memory.err_full))
            #     else:
            #         creep.say('ÍΩâÏ∞∏...{}'.format(creep.memory.err_full))
            # # ÏóêÎÑàÏßÄ Ïô∏ Îã§Î•∏Í≤å ÏûàÎäî ÏÉÅÌô©. Ïù¥ Í≤ΩÏö∞ Í∑∏ÎÉ• Îã§ Îñ®Íµ∞Îã§.
            # elif transfer_result == ERR_NOT_ENOUGH_ENERGY:
            #     stores = creep.carry
            #     for s in Object.keys(stores):
            #         if s == RESOURCE_ENERGY:
            #             continue
            #         a = creep.drop(s)
            #         break

        # ÏàòÎ¶¨
        elif creep.memory.priority == 3:
            if not creep.memory.work:
                creep.memory.priority = 2
                creep.say('Ïö¥ÏÜ°Îßå ÌïòÍ≤†ÏàòÎã§', True)

            repair = creep.pos.findClosestByRange(repairs)
            repair_result = creep.repair(repair)
            try:
                # Ïª®ÌÖåÏù¥ÎÑàÏôÄ 3Ïπ∏Ïù¥ÏÉÅ Îñ®Ïñ¥ÏßÄÎ©¥ Î≥µÍ∑ÄÌïúÎã§.
                if not creep.pos.inRangeTo(Game.getObjectById(creep.memory.pickup), 3) \
                        or creep.carry.energy == 0:
                    creep.memory.laboro = 0
                    creep.memory.priority = 0
                    creep.say('üêúÎäî Îö†Îö†', True)
                    del creep.memory.last_swap

                    return
            except:
                # Ïó¨Í∏∞ Í±∏Î¶¨Î©¥ Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä ÏÇ≠Ï†úÎêúÍ±∞ÏûÑ...
                creep.say('?? Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä!', True)
                del creep.memory.pickup
                creep.memory.priority = 1
                return

            if repair_result == ERR_NOT_IN_RANGE:
                creep.moveTo(repair, {'visualizePathStyle': {'stroke': '#ffffff'}})
            elif repair_result == ERR_INVALID_TARGET:
                creep.memory.priority = 0
            elif repair_result == ERR_NO_BODYPART:
                creep.memory.priority = 2
            elif repair_result == 0:
                if _.sum(Game.getObjectById(creep.memory.pickup).store) \
                        == Game.getObjectById(creep.memory.pickup).storeCapacity:
                    creep.say('ÏàòÎ¶¨Î≥¥Îã§ Ïö¥ÏÜ°!', True)
                    creep.memory.laboro = 0
                    creep.memory.priority = 0
                    # Ïª®ÌÖåÏù¥ÎÑà ÍΩâÏ∞®ÏÑú ÎùºÎ≥¥Î°ú 0Ïù∏Í±∏ ÌëúÍ∏∞.
                    creep.memory.container_full = 1
                    del creep.memory.last_swap
        return
